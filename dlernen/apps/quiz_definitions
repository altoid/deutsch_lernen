#!/usr/bin/env python

from dlernen import config
import argparse
import json
import requests
from pprint import pprint


def get_next_word_to_test(chosen_words):
    url = "%s/api/quiz_data" % config.Config.DB_URL
    payload = {
        "quizkey": "definitions",
        "word_ids": chosen_words['word_ids']
    }
    r = requests.put(url, json=payload)
    quiz_data = json.loads(r.text)
    if not quiz_data:
        return None

    # dig the word_ids out of the result and then find the articles for each word that is a noun.
    word_ids = [x['word_id'] for x in quiz_data]
    url = "%s/api/words" % config.Config.DB_URL
    payload = {
        "word_ids": word_ids
    }
    r = requests.put(url, json=payload)
    word_attributes = json.loads(r.text)

    # enrich the quiz_data by adding the articles
    word_id_to_article = {}
    for wa in word_attributes:
        for a in wa['attributes']:
            if a['attrkey'] == 'article':
                word_id_to_article[wa['word_id']] = a['attrvalue']

    for qd in quiz_data:
        if qd['word_id'] in word_id_to_article:
            qd['article'] = word_id_to_article[qd['word_id']]

    # pprint(quiz_data)
    return quiz_data[0]


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
                                     description="""
quiz_definitions (no args)
all words

quiz_definitions -l <wordlist_id> <wordlist_id> ...
all from a list

quiz_definitions -n <x> -r
n randomly chosen

quiz_definitions -n <x> -l <wordlist_id> <wordlist_id> ...
n randomly chosen from lists

quiz_definitions -n <x>
n most recent
""")

    parser.add_argument('-l', '--listids',
                        nargs='+',
                        type=int,
                        help='id of word list to use')
    parser.add_argument('-n', '--nwords',
                        type=int,
                        default=10,
                        help='quiz the n most recently added words.  defaults to 10.')
    parser.add_argument('-r', '--recent',
                        action='store_true',
                        help='pick most recently added words and quiz them.')
    cl_args = parser.parse_args()

    url = "%s/api/words/definition" % config.Config.DB_URL
    url = "%s?limit=%s&recent=%s" % (url, cl_args.nwords, cl_args.recent)
    if cl_args.listids:
        url = "%s&wordlist_id=%s" % (url, ','.join([str(x) for x in cl_args.listids]))

    pprint(url)

    r = requests.get(url)
    chosen_words = json.loads(r.text)

    done = False
    counter = 0
    while not done:
        row = get_next_word_to_test(chosen_words)

        if not row:
            print("es gibt keine Welten mehr zu erobern")
            break

        counter += 1
        print("[%s]" % counter, end=' ')

        if 'article' in row:
            print(row['article'], end=' ')

        print(row['word'])
        prompt = "hit return for answer, q to quit:  --> "
        answer = input(prompt).strip().lower()

        if answer.startswith('q'):
            done = True
            break

        print(row['definition']['attrvalue'])

        prompt = "correct? --> "
        answer = input(prompt).strip().lower()

        payload = {
            "quiz_id": row['quiz_id'],
            "word_id": row['word_id'],
            "attribute_id": row['definition']['attribute_id'],
            "presentation_count": row['definition']['presentation_count'],
            "correct_count": row['definition']['correct_count']
        }

        while len(answer) == 0:
            answer = input(prompt).strip().lower()

        if answer.startswith('y'):
            payload['correct_count'] += 1

        payload['presentation_count'] += 1

        url = "%s/api/quiz_data" % config.Config.DB_URL
        r = requests.post(url, data=payload)

    print('bis bald')
