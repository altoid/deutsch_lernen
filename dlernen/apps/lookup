#!/usr/bin/env python
# -*- python -*-

from dlernen import dsn
import argparse
import operator
from pprint import pprint
import requests
from dlernen.config import Config


def lookup(word):
    word = word.lower()

    regex_q = """
select
    pos_name,
    word,
    word_id,
    concat(attrkey, ':') attrkey,
    attrvalue value,
    pf.sort_order
from
    mashup_v
inner join pos_form pf on pf.attribute_id = mashup_v.attribute_id and pf.pos_id = mashup_v.pos_id
where word_id in
    (
    select
        word_id
    from
        mashup_v
    where
        word like '%%%(word)s%%' or attrvalue like '%%%(word)s%%'
    )
""" % {
        'word': word
    }

    exact_q = """
select
    pos_name,
    word,
    word_id,
    concat(attrkey, ':') attrkey,
    attrvalue value,
    pf.sort_order
from
    mashup_v
inner join pos_form pf on pf.attribute_id = mashup_v.attribute_id and pf.pos_id = mashup_v.pos_id
where word_id in
    (
    select
        word_id
    from
        mashup_v
    where
        word = '%(word)s'
    )
""" % {
        'word': word
    }

    q = exact_q if args.exact else regex_q
    c.execute(q)

    result = c.fetchall()

    if len(result) == 0:
        print("%s NOT FOUND:  %s" % ('#' * 33, word))
        return

    result = sorted(result, key=operator.itemgetter('word', 'sort_order'))

    # get the max width of all attr keys
    max_attr_width = 0
    max_tag_length = 0
    for r in result:
        if len(r['attrkey']) > max_attr_width:
            max_attr_width = len(r['attrkey'])
        tag_length = len("%s (%s)" % (r['word'], r['pos_name']))
        if tag_length > max_tag_length:
            max_tag_length = tag_length

    current_word_id = -1
    matched_ids = []
    for r in result:
        if r['word_id'] != current_word_id:
            print("%s" % ('=' * 66))
            current_word_id = r['word_id']
            tag = "%s (%s)" % (r['word'], r['pos_name'])
            matched_ids.append((current_word_id,))
        else:
            tag = ''

        print("%s %s %s" % (tag.ljust(max_tag_length + 10),
                            r['attrkey'].ljust(max_attr_width),
                            r['value']))

    # record this lookup
    q = """
insert into lookup (word_id) values (%s)
on duplicate key update count = count + 1
"""
    c.executemany(q, matched_ids)
    db.commit()


def widest_attrkey_len(result):
    """
    for output formatting purposes, return the length of the longest attrkey among the attributes in the result.

    :param result:
    :return:
    """

    # the attribute with the longest key
    longest_key = max(result['attributes'], key=lambda x: len(x['key']))
    return len(longest_key['key']) if longest_key else 0


def hanging_tag_width(result):
    return len("%s (%s)" % (result['word'], result['pos_name']))


def display_result(result, tagwidth, keywidth):

    tag = "%s (%s)" % (result['word'], result['pos_name'])
    print("%s" % ('=' * 66))

    for a in result['attributes']:
        display_key = "%s:" % a['key']
        print("%s %s %s" % (tag.ljust(tagwidth + 10),
                            display_key.ljust(keywidth + 1),  # add 1 for the : appended to the key name
                            a['value']))
        tag = ''


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("word",
                        nargs='+',
                        help="word to look up")
    parser.add_argument("--exact", action='store_true',
                        help="search for word verbatim, no substring matching")
    parser.add_argument("--api", action='store_true',
                        help="use REST api")
    args = parser.parse_args()

    db = dsn.getConnection()
    c = db.cursor(dictionary=True)

    if args.api:
        all_results = []
        for word in args.word:
            url = "%s/api/word/%s" % (Config.BASE_URL, word)
            r = requests.get(url)
            results = r.json()
            all_results += results
        pprint(all_results)
        keywidth = max([widest_attrkey_len(x) for x in all_results])
        tagwidth = max([hanging_tag_width(x) for x in all_results])

        for result in all_results:
            display_result(result, tagwidth, keywidth)

    else:
        for word in args.word:
            lookup(word)
