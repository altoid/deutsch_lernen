#!/usr/bin/env python

import argparse
import sys
import requests

from dlernen import config

from pprint import pprint


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-l', '--listids',
                        nargs='+',
                        type=int,
                        help='id of word list to use')

    cl_args = parser.parse_args()

    wordlist_ids = cl_args.listids if cl_args.listids else None

    url = "%s/api/words" % config.Config.DB_URL
    if wordlist_ids:
        wordlist_ids = map(str, wordlist_ids)
        args = ','.join(wordlist_ids)
        url = "%s?wordlist_id=%s" % (url, args)

    r = requests.get(url)
    if not r:
        print('oh shit')
        sys.exit()

    result = r.json()

    words_to_patch = []

    # get all the verbs
    attrs_to_patch = {
        'third_person_past',
        #        'past_participle'
    }
    result = list(filter(lambda x: x['pos_name'] == 'Verb', result))
    for w in result:
        tpp = list(filter(lambda x: x['attrkey'] in attrs_to_patch and x['attrvalue'] is None, w['attributes']))
        if tpp:
            words_to_patch.append(w)

    print("found %s verbs to patch" % (len(words_to_patch)))

    if not words_to_patch:
        print("nothing to do")
        sys.exit()

    # from the first word, extract all of the attr keys and their sort orders.  these are the same for
    # each of the words retrieved.
    # TODO this will have to do until i make an api call that retrieves the attr keys and sort orders for all
    #   the parts of speech.
    sort_order_to_attrkey = {}
    for a in words_to_patch[0]['attributes']:
        if a['attrkey'] in attrs_to_patch:
            sort_order_to_attrkey[a['sort_order']] = a['attrkey']

#    pprint(sort_order_to_attrkey)
    ordering = sorted(list(sort_order_to_attrkey.keys()))
#    pprint(ordering)

    payload = {
        "attributes_adding": []
    }

    for p in words_to_patch:
        attrkey_to_attrvalue = {}
        for a in p['attributes']:
            if a['attrkey'] in attrs_to_patch:
                attrkey_to_attrvalue[a['attrkey']] = a['attrvalue']
#        pprint(attrkey_to_attrvalue)

        payload['attributes_adding'].clear()

        for i in ordering:
            k = sort_order_to_attrkey[i]
            v = attrkey_to_attrvalue[k]

            if v:
                # don't bash an already-set value
                continue

            answer = input("%s [%s] ---> " % (p['word'], k))
            answer = answer.strip()

            if not answer:
                # skip to the next one
                continue

            if answer == 'q':
                sys.exit()

            d = {
                "attrvalue": answer,
                "attrkey": sort_order_to_attrkey[i]
            }
            payload["attributes_adding"].append(d)

#        pprint(payload)

        url = "%s/api/word/%s" % (config.Config.DB_URL, p['word_id'])
        r = requests.put(url, json=payload)
        if r.status_code != 200:
            pprint(p)
            pprint(answer)
            sys.exit()
